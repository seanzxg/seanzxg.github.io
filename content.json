{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://rainmar.com","root":"/"},"pages":[{"title":"关于","date":"2020-08-06T15:04:39.157Z","updated":"2020-08-06T15:04:39.157Z","comments":false,"path":"about/index.html","permalink":"http://rainmar.com/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930&#123; name: \"小光 Sean\", age: 26, gender: \"男\", profession: \"Web Developer\", experience: \"4年\", address: \"北京\", education: \"本科\", github: \"https://github.com/seanzxg\", blog: \"http://blog.rainmar.com\", email: \"seanxg@163.com\", description: \"致力于网站建设\", skills: [ [\"Html\", \"Javascript\", \"jQuery\", \"CSS\", \"ES6\", \"Node\"], [\"Webpack\", \"Gulp\"], [\"Less\",\"Sass\"], [\"Git\", \"SVN\"], [\"Vue\"], [\"Bootstrap\", \"SUI Mobile\", \"light7\"], [\"WordPress\", \"OpenCart\"], ], devTools: [ [\"Webstorm\", \"Visual Studio Code\", \"Notepad++\"], [\"Chrome DevTools\", \"Fiddler\"], [\"SourceTree\", \"TortoiseSVN\"], [\"SwitchHosts\"], [\"Navicat\", \"XAMPP\"], ]&#125;"},{"title":"分类","date":"2020-07-30T20:02:33.044Z","updated":"2019-11-05T09:53:42.832Z","comments":false,"path":"categories/index.html","permalink":"http://rainmar.com/categories/index.html","excerpt":"","text":"小光爱吃肉"},{"title":"标签","date":"2020-07-30T20:02:33.044Z","updated":"2019-11-05T09:44:10.063Z","comments":false,"path":"tags/index.html","permalink":"http://rainmar.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git操作锦集","slug":"Git操作锦集","date":"2020-08-06T15:14:08.083Z","updated":"2020-08-10T08:57:57.307Z","comments":true,"path":"ckdoabec50000n3jbbt0jbns6/","link":"","permalink":"http://rainmar.com/ckdoabec50000n3jbbt0jbns6/","excerpt":"","text":"一步完成add commit push12345678910111213141516171819202122# 复制下面代码，一键提交的函数function acp() &#123; log=$1 files=$2 if [ ! -n \"$files\" ]; then files=\".\" fi echo \"acp -----&gt; git add $files\" git add \"$files\" echo \"acp -----&gt; git commit -m $log\" git commit -m \"$log\" echo \"acp -----&gt; git push\" git push&#125;# 把上面一段代码复制到文件中# bash$ vim ~/.bashrc$ source ~/.bashrc# zsh$ vim ~/.zshrc$ source ~/.zshrc 使用12# commit 提交的输入信息 file可不填，默认是.$ acp &lt;commit&gt; [file] cherry-pick简介cherry-pick ：给定一个或多个现有提交，应用每个引入的更改，并记录每个提交的新提交。这要求您的工作树是干净的（HEAD提交没有任何修改）。 也就是说，cherry-pick可以把不同分支的指定一个或者多个提交合并到当前分支。 命令详解123456789101112131415161718192021222324252627# 将指定的提交应用到其他分支$ git cherry-pick &lt;Hash&gt;# 将某分支最近的一次提交转义到当前分支$ git cherry-pick &lt;branch&gt;# 将A、B两个提交合并到对当前分支$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;# 将A-B之间但是不包括A包括B的所有提交合并到当前分支$ git cherry-pick A..B # 将A-B之间包括A包括B的所有提交合并到当前分支$ git cherry-pick A^..B # 配置项$ git cherry-pick# -e 打开外部编辑器，编辑提交信息# -n 更新工作区和暂存区，不产生新的提交（适用于多次commit合并，并且需要修修改改再提交的）# -x 提交信息追加， (cherry picked from commit xxxx)# -s 追求作者签名， Signed-off-by: name &lt;xxx@163.com&gt;# -m 合并代码的时候，优先采取那个分支的代码变动。 1 代表当前分支（接收变动的分支） 2 代表来源分支的commit代码# 代码冲突# 解决完冲突继续执行$ git cherry-pick --continue# 放弃合并，回到操作前的状态$ git cherry-pick --abort# 退出cherry-pick，不会到操作前状态，代码保留。$ git cherry-pick --quit 流程12345678910# ① 先合并develop分支的hash的commit$ git cherry-pick -x -s -e &lt;develop hash&gt;# if 代码冲突$ git add .$ git cherry-pick --continue$ git push# ② 提交$ git push 版本回退 reset简介git reset - 将当前的HEAD重置为指定状态。简单讲就是HEAD为git提交树的指针，而reset就是控制HEAD来控制版本变换的。 git reset ：回滚到某次提交。 git reset --soft：此次提交之后的修改会被退回到暂存区。 git reset --hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。 回退123456# 查询要回滚的 commit_id$ git log # HEAD 就会指向此次的提交记录$ git reset --hard commit_id# 强制推送到远端$ git push --force 回退误操作后12345# reflog的日志样式中，会记录reset,commit,cherry-pic,rebase,revert,checkout等操作的版本# 放图$ git reflog# 找到你想回退的hash的提交，然后再次执行reset。$ git reset --hard [commit] 推荐方式123456# 建一条分支$ git checkout -b merge 3d7fa42# 将版本重置到最新版本位置$ git reset --soft 634b64d# 再次提交删除掉的记录即可回滚版本$ git push -u origin merge 注意回退操作适用于从最新的代码提交回退指定版本，如果需求是从中间某次提交不建议用git reset回退，在多人代码管理中，他人在git pull的时候，容易出现代码提交断层而增加不必要代码冲突 提交回滚 恢复一些现有的提交 1234# 回滚到上一个版本$ git revert HEAD -n$ git commit -m '回滚提交'$ git push 删除中间的commit1234567# 查找要删除的前一次提交的commit，并复制$ git log# 将commit替换成复制的值$ git rebase -i commit_id# 进入 Vim 编辑模式，将要删除的 commit 前面的 `pick` 改成 `drop`。如下图# 保存并退出 Vim$ git push --force Logs123456789101112131415161718192021222324# 基础打印alias glg='git log --stat'alias glgp='git log --stat -p'alias glgg='git log --graph'alias glgm='git log --graph --max-count=10'alias glo='git log --oneline --decorate'alias glog='git log --oneline --decorate --graph'# 下面两条仅显示提交时间方式差异，$cr 提交日期，按多久以前的方式显示 $ad 作者修订日期（可以用 -date= 选项定制格式）alias glol=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'\"alias glod=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset'\"# 在glol的基础上，显示修改的文件alias glols=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --stat\"# 在glods的基础上，日期格式缩短alias glods=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset' --date=short\"# 看所有分支提交状态$ alias glgga='git log --graph --decorate --all'$ alias gloga='git log --oneline --decorate --graph --all'$ alias glola=\"git log --graph --pretty='%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --all\" 删除远程的文件/文件夹出现以下情况适用： 1、由于本地修改了文件夹大全名大小写的原因，同步到git上并不区分大小写，造成了一些文件同步不了，所以要先把git远程库上文件夹删除掉，然后再重新同步 2、我们要在保留本地文件的情况下，删除远程仓库的文件。例如idea的配置文件 .idea被不小心提交到远程，本地不删除，远程删除，并且把相应的目录添加的.gitignore 12345678# 加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览$ git rm -r -n --cached &lt;files/folder&gt;# 删除指定文件或文件夹$ git rm -r --cached &lt;files/folder&gt;# 提交$ git commit -m \"commit\"# 推送$ git push 本地仓库更换绑定远程仓库1234# 查看所有远程仓库$ git remote -v# 查看指定远程仓库$ git remote show 方法一： 12# 设置远程仓库$ git remote set-url origin [url] 方法二： 12$ git remote rm origin$ git remote add origin http://192.168.100.235:9797/john/git_test.git 方法三： 12345cd path/to/project/.gitvim config# [remote \"origin\"]# url = git@xxx.com:mall-client/search.git 修改此url# fetch = +refs/heads/*:refs/remotes/origin/* 方法四： 工具都具有修改远程仓库的功能，例如SourceFrom","categories":[{"name":"git","slug":"git","permalink":"http://rainmar.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://rainmar.com/tags/git/"}]},{"title":"git常用命令清单","slug":"git常用命令清单","date":"2020-08-06T03:21:24.000Z","updated":"2020-08-10T08:34:05.297Z","comments":true,"path":"ckdoabecg0007n3jb3ynzc453/","link":"","permalink":"http://rainmar.com/ckdoabecg0007n3jb3ynzc453/","excerpt":"","text":"Git是每个程序员必备的日常用具。除了日常用的几个，还有些常用的总是记不住，做一下基本的整理。 脱离图形，无形装x，最为致命 基本名词 Working Directory：工作区 Stage Area：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git配置1234567891011121314# Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量$ git config# 所有的配置以及它们所在的文件$ git config --list --show-origin# 设置用户信息$ git config --global user.name \"John Doe\"$ git config --global user.email johndoe@example.com# 检查配置信息$ git config --list# 编辑Git配置文件$ git config -e [--global] 新建git库123456789# 在当前目录新建一个Git代码库$ cd [dir]$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 远程把项目克隆下来，包含项目和整个历史代码 [dir]指定目录$ git clone [url] [dir] 缓存区增、删1234567891011121314151617181920212223# 增# 添加当前目录的所有文件到暂存区$ git add .# 添加指定文件/文件夹（包括子目录）到暂存区$ git add [file1] [file2] ...$ git add [dir]# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345678910111213141516171819# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 通过新的一次commit，替换上一次版本提交# ① 如果工作区有修改被添加到缓存区(git add .)，连带着缓存重新提交# ② 如果缓存区无改动，则等于改写一次commit提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 远程操作12345678910111213141516171819202122232425262728# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 本地的分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。# 适用于新的分支或者过期的分支或者远程被删除的分支git push -u origin [branch]# 修改远程分支$ git remote set-url origin [url]# 另一种修改远程分支$ git remote remove origin$ git remote add origin [url] 撤销缓存区123456789101112# 撤销# 撤销暂存区添加的所有文件$ git reset$ git restore [--staged|-S] .# 无任何效果$ git reset --soft# 同时撤销暂存区和工作区的修改，回复到上一次提交的状态(本地代码修改会丢失，慎用)$ git reset --hard# 等同于git reset --hard HEAD 工作区12345678# 撤销工作区指定文件当前的版本$ git checkout [file]# 撤销工作区的所有文件当前版本$ git checkout .$ git restore .w# 撤销某个文件的所有文件当前版本 本地仓库123456789101112131415161718# 恢复某个commit的指定文件到暂存区$ git checkout [commit] [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard [HEAD]# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 分支123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系(很少用)$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch [--set-upstream | -u] [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 同步本地的远程分支$ git remote show origin$ git remote prune origin# 删除本地多余的分支$ git branch -D [branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示暂存区和工作区的差异$ git diff# 显示工作区/缓存区与当前分支最新commit之间的差异$ git diff HEAD# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示指定文件相关的每一次diff$ git log -p [file]# 搜索提交历史，根据关键词$ git log --grep change# 我理解为最近做的操作$ git reflog# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename] 不怎么用1234567891011121314# 搜索提交历史，根据关键词（试了不好用）$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\" 暂存1234567891011121314# 存储工作区git stash# 存储工作区并添加备注内容git stash save 'development'# 查看已贮藏区列表git stash list# 应用最新贮藏的内容(应用后不删除该贮藏)git stash apply# 应用最新贮藏的内容(应用后该贮藏的内容会被删除！)git stash pop# 删除最新贮藏的内容git stash drop# 都可以指定操作任意一个已贮藏的内容，只需要在后面跟入stash@&#123;1&#125;索引，输入git stash list 查看索引git stash apply git stash pop git stash drop","categories":[{"name":"git","slug":"git","permalink":"http://rainmar.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://rainmar.com/tags/git/"}]},{"title":"微信网页调整字体大小导致页面错乱","slug":"微信网页调整字体大小导致页面错乱","date":"2020-01-19T05:56:46.000Z","updated":"2020-08-06T15:04:39.156Z","comments":true,"path":"ckdoabecj000dn3jbbsz4c14b/","link":"","permalink":"http://rainmar.com/ckdoabecj000dn3jbbsz4c14b/","excerpt":"","text":"解决问题原理：阻止页面调整字体大小的事件，来达到避免字体变大导致页面的适配。 解决：ios123body &#123; -webkit-text-size-adjust: 100% !important;&#125; android123456789101112131415(function() &#123; if (typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\") &#123; handleFontSize(); &#125; else &#123; document.addEventListener(\"WeixinJSBridgeReady\", handleFontSize, false); &#125; function handleFontSize() &#123; // 设置网页字体为默认大小 WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); // 重写设置网页字体大小的事件 WeixinJSBridge.on('menu:setfont', function() &#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); &#125;); &#125;&#125;)();","categories":[{"name":"记录","slug":"记录","permalink":"http://rainmar.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://rainmar.com/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"问题","slug":"问题","permalink":"http://rainmar.com/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"nodejs中require的加载规则","slug":"nodejs中require的加载规则","date":"2019-12-23T07:39:16.000Z","updated":"2020-08-06T15:04:39.155Z","comments":true,"path":"ckdoabech000bn3jb3qaa4a9m/","link":"","permalink":"http://rainmar.com/ckdoabech000bn3jb3qaa4a9m/","excerpt":"","text":"require方法的加载规则 优先从缓存中加载 核心模块 路径形式的模块 第三方模块 1.有线从缓存中加载测试例子 12345678910111213141516171819// a.jsconsole.log('A load')// b.jsconsole.log('B load')require('./a')// index1.jsrequire('./a')require('./b')// A load// B load// index2.jsrequire('./b')require('./a')// B load// A load 可以看出： index1.js加载a，然后加载b.js，而此时b中a已经在index1.js被加载，并没有打印两次A load。 Index2.js加载了b，然后再加a，而输出先Bload 然后是a.js，而a没有输出。 总结：当一个模块已经被加载后，会被存到require.cache中，从require.cache中根据传入的id,取出该对象的exports值，不会再次执行该模块代码 2.核心模块核心模块的本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了 例如： 12require('fs')require('http') 3.路径模块加载自己写的莫快递，以下是加载方式 12345678// 相对路径var a = require(&apos;./a&apos;)// 相对路径var a = require(&apos;../a&apos;)// 根路径var a = require(&apos;/a&apos;)// 根路径var a = require(&apos;~/src/a&apos;) 4.第三方模块 第三方模块，通过npm安装到本地的node_modules 使用的时候，可以通过require(&#39;包名&#39;)的方式进行加载才可以使用 第三方包和核心模块的名称不能一样 var template = require(‘aaa’) 先找到当前文件所处目录中的 node_modules 目录 然后根据以下方式找到文件中的 main 属性 main 属性中就记录了 aaa 的入口模块 然后加载使用这个第三方包，但是实际上最终加载的还是文件 如果 package.json 文件不存在或者 main 指定的入口模块是也没有 则 node 会自动找该目录下的 index.js，也就是说 index.js 会作为一个默认备选项 如果以上所有任何一个条件都不成立，则会进入上一级目录中的 node_modules 目录查找 如果上一级还没有，则继续往上上一级查找 如果直到当前磁盘根目录还找不到，最后报错： can not find module aaa","categories":[{"name":"前端","slug":"前端","permalink":"http://rainmar.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://rainmar.com/tags/nodejs/"}]},{"title":"搭建一个自己的npm仓库","slug":"搭建一个自己的npm仓库","date":"2019-11-21T08:32:42.000Z","updated":"2020-08-06T15:04:39.156Z","comments":true,"path":"ckdoabecl000gn3jb6k4pfo0r/","link":"","permalink":"http://rainmar.com/ckdoabecl000gn3jb6k4pfo0r/","excerpt":"","text":"全局安装verdaccio1npm install –g verdaccio 执行1234567verdaccio// 执行后如下 warn --- config file - /Users/sean/.config/verdaccio/config.yaml warn --- Verdaccio started warn --- Plugin successfully loaded: verdaccio-htpasswd warn --- Plugin successfully loaded: verdaccio-audit warn --- http address - http://localhost:4873/ - verdaccio/4.3.4 Ctrl+c停止执行 配置文件：当前用户根路径下.config/verdaccio/config.yaml 安装pm2 (进程管理器)1npm install –g pm2 进程管理启动1pm2 start verdaccio 配置nginx反向代理12345678server &#123; listen 80; server_name npm.rainmar.com; location / &#123; proxy_pass http://127.0.0.1:4873/; proxy_set_header Host $host; &#125;&#125; centos的nginx配置文件在/etc/nginx/conf.d/,新建配置文件 ubuntu的nginx配置文件在/etc/nginx/sites-available， 创建npm.rainmar.com配置文件， 贴入上图配置 ln -sfv /etc/nginx/sites-available/npm.rainmar.com /etc/nginx/sites-enabled/npm.rainmar.com 最后可以在浏览器访问 npm.rainmar.com","categories":[{"name":"linux","slug":"linux","permalink":"http://rainmar.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://rainmar.com/tags/linux/"}]},{"title":"Vue Bus","slug":"Vue-Bus","date":"2019-11-14T11:21:19.000Z","updated":"2020-08-06T15:04:39.154Z","comments":true,"path":"ckdoabecf0006n3jbhd9ebbj9/","link":"","permalink":"http://rainmar.com/ckdoabecf0006n3jbhd9ebbj9/","excerpt":"","text":"Vue eventbusvue-bus 参考这个插件，花10分钟看一下源码。 源码讲解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758防御型分号，防止有可能被解析错误;(function() &#123; var vueBus = &#123;&#125; vueBus.install = function (Vue) &#123; var version = Number(Vue.version.split('.')[0]) if (version &lt; 2) return //check Vue version var bus = new Vue() // 定义了另一种赋值类型 // 双向绑定Vue.prototype的$bus属性，监听赋值变化 // //alt way to send an event (this.$bus=['event_name',arg1,arg2]) or this.$bus = 'change' Object.defineProperty(Vue.prototype, '$bus', &#123; //for \"this.$bus\" get: function () &#123; return bus &#125;, set: function (evt) &#123; if (typeof evt === 'string') evt = [evt] bus.$emit.apply(bus, evt) // 等价于bus.$emit(...evt) &#125; &#125;) // 混入,以下用法实现监听// =========================================// export default &#123;// name: 'name',// mounted() &#123;// ...// &#125;,// $bus: &#123;// 'evnetname': (value) =&gt; &#123;// ....// &#125;// &#125;// &#125;// ========================================== Vue.mixin(&#123; created: function () &#123; //add option \"$bus\" instead bus.$on in created hook var $bus = this.$options.$bus this.$busListeners = &#123;&#125; for (var name in $bus) &#123; this.$busListeners[name] = $bus[name].bind(this) //rebind and remember each declared listener bus.$on(name, this.$busListeners[name]) //register a listener for the event &#125; &#125;, beforeDestroy: function () &#123; //unreg listeners for (var name in this.$busListeners) bus.$off(name, this.$busListeners[name]) this.$busListeners = null &#125; &#125;) &#125; // if module if (typeof exports === 'object') &#123; module.exports = vueBus; return &#125; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define([], function()&#123; return vueBus &#125;); return &#125; // if direct include if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; window.VueBus = vueBus window.Vue.use(vueBus) //auto-activation &#125;&#125;)() Nuxt eventbusplugins/bus.js123456import Vue from 'vue'const bus = &#123;&#125;bus.install = function (Vue) &#123; Vue.prototype.$bus = new Vue()&#125;Vue.use(bus) 联合注入12345import Vue from 'vue';export default (ctx, inject) =&gt; &#123; const bus = new Vue; inject('bus', bus);&#125;; nuxt.config.js 配置12345module.exports = &#123; '~/plugins/bus-inject.js', //or 仅用于客户端 &#123;src:'~/plugins/bus-inject.js', ssr: false&#125;&#125; 使用发送事件（组件中）1this.$bus.$emit('message', data) 接收事件123this.$bus.$on('name-of-event', (data) &#123; ...deal&#125; 联合方式注入使用使用12345678910export default &#123; mounted() &#123; this.$bus.$on('messageSend', (data) =&gt; &#123; ...deal &#125;) &#125;, asyncData(&#123;app&#125;) &#123; // app.$bus 同样生效 &#125;&#125; store中使用1234567891011121314export const action = &#123; async sendMessage(&#123;commit&#125;)&#123; const message = await this.$axios.post('/path/to/message', &#123;...data&#125;) commit('pushMessage', message); this.$bus.$emit('messageSend'); &#125;&#125;export const mutation = &#123; async sendMessage(&#123;commit&#125;)&#123; const message = await this.$axios.post('/path/to/message', &#123;...data&#125;) commit('pushMessage', message); this.$bus.$emit('messageSend'); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://rainmar.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://rainmar.com/tags/Vue/"}]},{"title":"Hexo博客-搭建","slug":"Hexo博客-搭建","date":"2019-11-06T06:17:06.000Z","updated":"2020-08-06T15:04:39.153Z","comments":true,"path":"ckdoabeca0002n3jb5eoscjqe/","link":"","permalink":"http://rainmar.com/ckdoabeca0002n3jb5eoscjqe/","excerpt":"","text":"开始为何是Hexo？我简单搜了一下博客框架，大概看了几种，作为一个前端，我选择了Hexo。原因如下： 支持Markdown 轻量级，不需要后台或者数据库 一键部署，不需要配置太多的环境，而且跟前端工作相近，打包，生成静态文件等 插件挺多，虽然还没咋用 找到了我喜欢的主题 基于node.js，熟悉感 More info: Hexo Doc 环境一台电脑，最好是linux系统或者mac os系统 Node.js（安装稳定版即可 如果你有意境有了node环境，确保自己的版本不低于8.6即可） Git tip：如果某些原因需要多版本node，安装nvm进行版本控制 建站1.安装Hexo Cli1$ npm install -g hexo-cli 2.构建博客项目123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo init &lt;folder&gt; 执行过程是把 hexo-starter 把项目克隆到folder目录下，顺带把landscape主题克隆到theme/目录,最后把相关的git的都删掉。给你一个初始化的项目 npm install 安装项目运行相关的依赖包 npm相关的操作请查阅npm文档 tip: 我们在用别人的主题的时候，那么你会把相关主题克隆到theme目录下，导致项目中有其他项目git，则无法提交。以submodule方式提交，因为你修改了__config配置文件，也是无法提交。结果就只有删除掉你克隆的主题.git文件。如果有方案保持其他项目的git管理，又能改动主题的配置文件，同时能提交到自己的仓库，请指教 3.配置博客网站的配置产考文档 hexo 配置 主题引用配置各主题稍有差异，挑一个自己喜欢的主题根据文档来配置。主题 github搜hexo theme关键词也能搜到 说一个注意点： 如果博客是www.xxx.com/blog 那么你的root配置则配置/blog/ 如果博客是blog.xxx.com/ 那么你的root配置则配置/ tip：root是在你打包构建的时候 生成的public文件中，html引用资源的路径。本地可以配置nginx模拟一下服务器访问，确保生成的资源可访问。 4.常用命令12345678// 构建项目，生成静态文件hexo generate// 发布项目到服务器/githubhexo deploy// 本地运行服务 默认：localhost:4000hexo server// 清理构建项目生成的文件hexo clean 打开package.json中script部分显示 1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot;, &quot;auto&quot;: &quot;npm run clean &amp; npm run generate &amp; npm run deploy&quot;&#125; npm install装完依赖后，可以通过 123456npm run cleannpm run buildnpm run deploynpm run server一键清除、构建、部署服务npm run auto 以上执行等同于常用命令 执行到这里，你已经搭成了可以在本地运行，可构建的博客项目了，恭喜 那么问题来了，如何把你项目部署到服务器或者github pages呢？ 请看下期","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://rainmar.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo博客-服务器部署","slug":"Hexo博客-服务器部署","date":"2019-11-06T06:17:06.000Z","updated":"2020-08-07T00:59:57.428Z","comments":true,"path":"ckdoabece0005n3jbd9v3f6rb/","link":"","permalink":"http://rainmar.com/ckdoabece0005n3jbd9v3f6rb/","excerpt":"","text":"开始通过上一期Hexo博客-搭建,能够构建一个完整 可运行博客的项目，配置相关参数，构建生成静态文件。 本期讲如何把项目构建并部署到服务器上 流程总览服务器环境安装-&gt;创建git用户-&gt;博客git hook-&gt;nginx配置-&gt;hexo deploy 部署1.环境安装nginx git 博主的服务器是ubuntu 1$ apt install nginx git -y 2.创建git环境① 以root用户登录12345$ sudo adduser git$ su git$ cd$ mkdir .ssh &amp;&amp; chmod 700 .ssh$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys ② 把 SSH 公钥添加到authorized_keys文件中简单说就是把你的ssh添加到服务器的authorized_keys文件中，以后服务器在拉取代码等操作不用登录 怎么配置ssh？ 例如github，头像&gt;setting&gt;SSH and GPG keys 生成ssh和添加ssh到本机的链接生成ssh教程 配置完ssh后，在本机的命令行做以下操作 1234$ cd ~$ ls -al ~/.ssh把`id_rsa.pub`文件发到服务器上$ scp root@xxx.xxx.xxx.xxx:/path/to/server .ssh/id_rsa.pub 服务器执行 1$ cat /path/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 为了安全考虑，需要禁止掉git用户shell登录，参考 git服务器配置 3. 创建git仓库目录 配置git hooks① 创建一个名为blog的git裸仓库123$ mkdir /path/to/repo$ cd /path/to/repo$ git init --bare blog.git ② 创建 hook 钩子函数1vim /var/repo/blog.git/hooks/post-receive ③ 输入了内容如下12#!/bin/sh$ git --work-tree=/path/to/blog/ --git-dir=/path/to/repo/blog.git checkout -f ④ 改变blog.git的目录拥有者权限1$ chown -R git:git blog.git ⑤ 创建博客静态文件目录123mkdir /path/to/blog/chown -R git:git /path/tolog/chmod -R 755 /path/to/blog/ ⑥ 调试一下是否部署成功1git clone git@服务器ip:/path/to/repo/blog.git 如果克隆到当前文件中一个空的blog文件，那么你的blog配置就成功了。 4. 服务器nginx配置① 域名配置1vim /etc/nginx/site-available/rainmar.com rainmar.com是我的域名，并做好了ip和域名映射。 如果你没有域名或者本地调试，默认是default ② nginx配置1234567891011server &#123; listen 80; listen [::]:80; server_name rainmar.com www.rainmar.com; index index.html; location / &#123; alias /data/projects/blog/; index index.html; try_files $uri $uri/ /index.html =404; &#125;&#125; ③ 重启nginx1/etc/init.d/nginx restart 5.hexo deploy① 安装deploy1$ npm install hexo-deployer-git --save ② 打开博客项目根目录下_config.yml文件,配置如下1234deploy: type: git repository: git@ip或域名:/path/to/blog.git branch: master ③配置一键部署，打开package.json文件1234567\"scripts\": &#123; \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\", \"c\": \"npm run clean &amp; npm run build &amp; npm run deploy\" &#125; npm run c 服务器一键部署（一键执行清理，构建，部署服务器） 参考文献、文档git仓库和项目源码分离 git init 和 git init –bare HEXO 部署到云服务器详细指南","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://rainmar.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"服务器","slug":"服务器","permalink":"http://rainmar.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}]}