{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://rainmar.com","root":"/"},"pages":[{"title":"关于","date":"2020-07-30T20:02:33.044Z","updated":"2020-04-08T09:09:02.090Z","comments":false,"path":"about/index.html","permalink":"http://rainmar.com/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930&#123; name: \"小光 Sean\", age: 26, gender: \"男\", profession: \"Web Developer\", experience: \"4年\", address: \"北京\", education: \"本科\", github: \"https://github.com/seanzxg\", blog: \"http://blog.rainmar.com\", email: \"seanxg@163.com\", description: \"致力于网站建设\", skills: [ [\"Html\", \"Javascript\", \"jQuery\", \"CSS\", \"ES6\", \"Node\"], [\"Webpack\", \"Gulp\"], [\"Less\",\"Sass\"], [\"Git\", \"SVN\"], [\"Vue\"], [\"Bootstrap\", \"SUI Mobile\", \"light7\"], [\"WordPress\", \"OpenCart\"], ], devTools: [ [\"Webstorm\", \"Visual Studio Code\", \"Notepad++\"], [\"Chrome DevTools\", \"Fiddler\"], [\"SourceTree\", \"TortoiseSVN\"], [\"SwitchHosts\"], [\"Navicat\", \"XAMPP\"], ]&#125;"},{"title":"分类","date":"2020-07-30T20:02:33.044Z","updated":"2019-11-05T09:53:42.832Z","comments":false,"path":"categories/index.html","permalink":"http://rainmar.com/categories/index.html","excerpt":"","text":"小光爱吃肉"},{"title":"标签","date":"2020-07-30T20:02:33.044Z","updated":"2019-11-05T09:44:10.063Z","comments":false,"path":"tags/index.html","permalink":"http://rainmar.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微信网页调整字体大小导致页面错乱","slug":"微信网页调整字体大小导致页面错乱","date":"2020-01-19T05:56:46.000Z","updated":"2020-04-08T09:09:02.089Z","comments":true,"path":"ckddv3dsa00083tjb2uau3xeg/","link":"","permalink":"http://rainmar.com/ckddv3dsa00083tjb2uau3xeg/","excerpt":"","text":"解决问题原理：阻止页面调整字体大小的事件，来达到避免字体变大导致页面的适配。 解决：ios123body &#123; -webkit-text-size-adjust: 100% !important;&#125; android123456789101112131415(function() &#123; if (typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\") &#123; handleFontSize(); &#125; else &#123; document.addEventListener(\"WeixinJSBridgeReady\", handleFontSize, false); &#125; function handleFontSize() &#123; // 设置网页字体为默认大小 WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); // 重写设置网页字体大小的事件 WeixinJSBridge.on('menu:setfont', function() &#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); &#125;); &#125;&#125;)();","categories":[{"name":"记录","slug":"记录","permalink":"http://rainmar.com/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://rainmar.com/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"问题","slug":"问题","permalink":"http://rainmar.com/tags/%E9%97%AE%E9%A2%98/"}]},{"title":"nodejs中require的加载规则","slug":"nodejs中require的加载规则","date":"2019-12-23T07:39:16.000Z","updated":"2020-04-08T09:09:02.089Z","comments":true,"path":"ckddv3ds800063tjb59ql7amy/","link":"","permalink":"http://rainmar.com/ckddv3ds800063tjb59ql7amy/","excerpt":"","text":"require方法的加载规则 优先从缓存中加载 核心模块 路径形式的模块 第三方模块 1.有线从缓存中加载测试例子 12345678910111213141516171819// a.jsconsole.log('A load')// b.jsconsole.log('B load')require('./a')// index1.jsrequire('./a')require('./b')// A load// B load// index2.jsrequire('./b')require('./a')// B load// A load 可以看出： index1.js加载a，然后加载b.js，而此时b中a已经在index1.js被加载，并没有打印两次A load。 Index2.js加载了b，然后再加a，而输出先Bload 然后是a.js，而a没有输出。 总结：当一个模块已经被加载后，会被存到require.cache中，从require.cache中根据传入的id,取出该对象的exports值，不会再次执行该模块代码 2.核心模块核心模块的本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了 例如： 12require('fs')require('http') 3.路径模块加载自己写的莫快递，以下是加载方式 12345678// 相对路径var a = require(&apos;./a&apos;)// 相对路径var a = require(&apos;../a&apos;)// 根路径var a = require(&apos;/a&apos;)// 根路径var a = require(&apos;~/src/a&apos;) 4.第三方模块 第三方模块，通过npm安装到本地的node_modules 使用的时候，可以通过require(&#39;包名&#39;)的方式进行加载才可以使用 第三方包和核心模块的名称不能一样 var template = require(‘aaa’) 先找到当前文件所处目录中的 node_modules 目录 然后根据以下方式找到文件中的 main 属性 main 属性中就记录了 aaa 的入口模块 然后加载使用这个第三方包，但是实际上最终加载的还是文件 如果 package.json 文件不存在或者 main 指定的入口模块是也没有 则 node 会自动找该目录下的 index.js，也就是说 index.js 会作为一个默认备选项 如果以上所有任何一个条件都不成立，则会进入上一级目录中的 node_modules 目录查找 如果上一级还没有，则继续往上上一级查找 如果直到当前磁盘根目录还找不到，最后报错： can not find module aaa","categories":[{"name":"前端","slug":"前端","permalink":"http://rainmar.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://rainmar.com/tags/nodejs/"}]},{"title":"搭建一个自己的npm仓库","slug":"搭建一个自己的npm仓库","date":"2019-11-21T08:32:42.000Z","updated":"2020-04-08T09:09:02.089Z","comments":true,"path":"ckddv3dsc000b3tjb7wbs6ugx/","link":"","permalink":"http://rainmar.com/ckddv3dsc000b3tjb7wbs6ugx/","excerpt":"","text":"全局安装verdaccio1npm install –g verdaccio 执行1234567verdaccio// 执行后如下 warn --- config file - /Users/sean/.config/verdaccio/config.yaml warn --- Verdaccio started warn --- Plugin successfully loaded: verdaccio-htpasswd warn --- Plugin successfully loaded: verdaccio-audit warn --- http address - http://localhost:4873/ - verdaccio/4.3.4 Ctrl+c停止执行 配置文件：当前用户根路径下.config/verdaccio/config.yaml 安装pm2 (进程管理器)1npm install –g pm2 进程管理启动1pm2 start verdaccio 配置nginx反向代理12345678server &#123; listen 80; server_name npm.rainmar.com; location / &#123; proxy_pass http://127.0.0.1:4873/; proxy_set_header Host $host; &#125;&#125; centos的nginx配置文件在/etc/nginx/conf.d/,新建配置文件 ubuntu的nginx配置文件在/etc/nginx/sites-available， 创建npm.rainmar.com配置文件， 贴入上图配置 ln -sfv /etc/nginx/sites-available/npm.rainmar.com /etc/nginx/sites-enabled/npm.rainmar.com 最后可以在浏览器访问 npm.rainmar.com","categories":[{"name":"linux","slug":"linux","permalink":"http://rainmar.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://rainmar.com/tags/linux/"}]},{"title":"Vue Bus","slug":"Vue-Bus","date":"2019-11-14T11:21:19.000Z","updated":"2020-06-09T06:54:02.087Z","comments":true,"path":"ckddv3ds700053tjbayy71qnw/","link":"","permalink":"http://rainmar.com/ckddv3ds700053tjbayy71qnw/","excerpt":"","text":"Vue eventbusvue-bus 参考这个插件，花10分钟看一下源码。 源码讲解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758防御型分号，防止有可能被解析错误;(function() &#123; var vueBus = &#123;&#125; vueBus.install = function (Vue) &#123; var version = Number(Vue.version.split('.')[0]) if (version &lt; 2) return //check Vue version var bus = new Vue() // 定义了另一种赋值类型 // 双向绑定Vue.prototype的$bus属性，监听赋值变化 // //alt way to send an event (this.$bus=['event_name',arg1,arg2]) or this.$bus = 'change' Object.defineProperty(Vue.prototype, '$bus', &#123; //for \"this.$bus\" get: function () &#123; return bus &#125;, set: function (evt) &#123; if (typeof evt === 'string') evt = [evt] bus.$emit.apply(bus, evt) // 等价于bus.$emit(...evt) &#125; &#125;) // 混入,以下用法实现监听// =========================================// export default &#123;// name: 'name',// mounted() &#123;// ...// &#125;,// $bus: &#123;// 'evnetname': (value) =&gt; &#123;// ....// &#125;// &#125;// &#125;// ========================================== Vue.mixin(&#123; created: function () &#123; //add option \"$bus\" instead bus.$on in created hook var $bus = this.$options.$bus this.$busListeners = &#123;&#125; for (var name in $bus) &#123; this.$busListeners[name] = $bus[name].bind(this) //rebind and remember each declared listener bus.$on(name, this.$busListeners[name]) //register a listener for the event &#125; &#125;, beforeDestroy: function () &#123; //unreg listeners for (var name in this.$busListeners) bus.$off(name, this.$busListeners[name]) this.$busListeners = null &#125; &#125;) &#125; // if module if (typeof exports === 'object') &#123; module.exports = vueBus; return &#125; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define([], function()&#123; return vueBus &#125;); return &#125; // if direct include if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; window.VueBus = vueBus window.Vue.use(vueBus) //auto-activation &#125;&#125;)() Nuxt eventbusplugins/bus.js123456import Vue from 'vue'const bus = &#123;&#125;bus.install = function (Vue) &#123; Vue.prototype.$bus = new Vue()&#125;Vue.use(bus) 联合注入12345import Vue from 'vue';export default (ctx, inject) =&gt; &#123; const bus = new Vue; inject('bus', bus);&#125;; nuxt.config.js 配置12345module.exports = &#123; '~/plugins/bus-inject.js', //or 仅用于客户端 &#123;src:'~/plugins/bus-inject.js', ssr: false&#125;&#125; 使用发送事件（组件中）1this.$bus.$emit('message', data) 接收事件123this.$bus.$on('name-of-event', (data) &#123; ...deal&#125; 联合方式注入使用使用12345678910export default &#123; mounted() &#123; this.$bus.$on('messageSend', (data) =&gt; &#123; ...deal &#125;) &#125;, asyncData(&#123;app&#125;) &#123; // app.$bus 同样生效 &#125;&#125; store中使用1234567891011121314export const action = &#123; async sendMessage(&#123;commit&#125;)&#123; const message = await this.$axios.post('/path/to/message', &#123;...data&#125;) commit('pushMessage', message); this.$bus.$emit('messageSend'); &#125;&#125;export const mutation = &#123; async sendMessage(&#123;commit&#125;)&#123; const message = await this.$axios.post('/path/to/message', &#123;...data&#125;) commit('pushMessage', message); this.$bus.$emit('messageSend'); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://rainmar.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://rainmar.com/tags/Vue/"}]},{"title":"Hexo博客-搭建","slug":"Hexo博客-搭建","date":"2019-11-06T06:17:06.000Z","updated":"2020-04-08T09:09:02.088Z","comments":true,"path":"ckddv3dry00003tjbf6wf8rfl/","link":"","permalink":"http://rainmar.com/ckddv3dry00003tjbf6wf8rfl/","excerpt":"","text":"开始为何是Hexo？我简单搜了一下博客框架，大概看了几种，作为一个前端，我选择了Hexo。原因如下： 支持Markdown 轻量级，不需要后台或者数据库 一键部署，不需要配置太多的环境，而且跟前端工作相近，打包，生成静态文件等 插件挺多，虽然还没咋用 找到了我喜欢的主题 基于node.js，熟悉感 More info: Hexo Doc 环境一台电脑，最好是linux系统或者mac os系统 Node.js（安装稳定版即可 如果你有意境有了node环境，确保自己的版本不低于8.6即可） Git tip：如果某些原因需要多版本node，安装nvm进行版本控制 建站1.安装Hexo Cli1$ npm install -g hexo-cli 2.构建博客项目123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo init &lt;folder&gt; 执行过程是把 hexo-starter 把项目克隆到folder目录下，顺带把landscape主题克隆到theme/目录,最后把相关的git的都删掉。给你一个初始化的项目 npm install 安装项目运行相关的依赖包 npm相关的操作请查阅npm文档 tip: 我们在用别人的主题的时候，那么你会把相关主题克隆到theme目录下，导致项目中有其他项目git，则无法提交。以submodule方式提交，因为你修改了__config配置文件，也是无法提交。结果就只有删除掉你克隆的主题.git文件。如果有方案保持其他项目的git管理，又能改动主题的配置文件，同时能提交到自己的仓库，请指教 3.配置博客网站的配置产考文档 hexo 配置 主题引用配置各主题稍有差异，挑一个自己喜欢的主题根据文档来配置。主题 github搜hexo theme关键词也能搜到 说一个注意点： 如果博客是www.xxx.com/blog 那么你的root配置则配置/blog/ 如果博客是blog.xxx.com/ 那么你的root配置则配置/ tip：root是在你打包构建的时候 生成的public文件中，html引用资源的路径。本地可以配置nginx模拟一下服务器访问，确保生成的资源可访问。 4.常用命令12345678// 构建项目，生成静态文件hexo generate// 发布项目到服务器/githubhexo deploy// 本地运行服务 默认：localhost:4000hexo server// 清理构建项目生成的文件hexo clean 打开package.json中script部分显示 1234567&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot;, &quot;auto&quot;: &quot;npm run clean &amp; npm run generate &amp; npm run deploy&quot;&#125; npm install装完依赖后，可以通过 123456npm run cleannpm run buildnpm run deploynpm run server一键清除、构建、部署服务npm run auto 以上执行等同于常用命令 执行到这里，你已经搭成了可以在本地运行，可构建的博客项目了，恭喜 那么问题来了，如何把你项目部署到服务器或者github pages呢？ 请看下期","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://rainmar.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo博客-服务器部署","slug":"Hexo博客-服务器部署","date":"2019-11-06T06:17:06.000Z","updated":"2020-04-08T09:09:02.088Z","comments":true,"path":"ckddv3ds300023tjb3ewacqo3/","link":"","permalink":"http://rainmar.com/ckddv3ds300023tjb3ewacqo3/","excerpt":"","text":"开始通过上一期Hexo博客-搭建,能够构建一个完整 可运行博客的项目，配置相关参数，构建生成静态文件。 本期讲如何把项目构建并部署到服务器上 流程总览服务器环境安装-&gt;创建git用户-&gt;博客git hook-&gt;nginx配置-&gt;hexo deploy 部署1.环境安装nginx git 博主的服务器是ubuntu 1$ apt install nginx git -y 2.创建git环境① 以root用户登录12345$ sudo adduser git$ su git$ cd$ mkdir .ssh &amp;&amp; chmod 700 .ssh$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys ② 把 SSH 公钥添加到authorized_keys文件中简单说就是把你的ssh添加到服务器的authorized_keys文件中，以后服务器在拉取代码等操作不用登录 怎么配置ssh？ 例如github，头像&gt;setting&gt;SSH and GPG keys 生成ssh和添加ssh到本机的链接生成ssh教程 配置完ssh后，在本机的命令行做以下操作 1234$ cd ~$ ls -al ~/.ssh把`id_rsa.pub`文件发到服务器上$ scp root@xxx.xxx.xxx.xxx:/path/to/server .ssh/id_rsa.pub 服务器执行 1$ cat /path/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 为了安全考虑，需要禁止掉git用户shell登录，参考 git服务器配置 3. 创建git仓库目录 配置git hooks① 创建一个名为blog的git裸仓库123$ mkdir /path/to/repo$ cd /path/to/repo$ git init --bare blog.git ② 创建 hook 钩子函数1vim /var/repo/blog.git/hooks/post-receive ③ 输入了内容如下12#!/bin/sh$ git --work-tree=/path/to/blog/ --git-dir=/path/to/repo/blog.git checkout -f ④ 改变blog.git的目录拥有者权限1$ chown -R git:git blog.git ⑤ 创建博客静态文件目录123mkdir /path/to/blog/chown -R git:git /path/to/blog/chmod -R 755 /path/to/blog/ ⑥ 调试一下是否部署成功1git clone git@服务器ip:/path/to/repo/blog.git 如果克隆到当前文件中一个空的blog文件，那么你的blog配置就成功了。 4. 服务器nginx配置① 域名配置1vim /etc/nginx/site-available/rainmar.com rainmar.com是我的域名，并做好了ip和域名映射。 如果你没有域名或者本地调试，默认是default ② nginx配置1234567891011server &#123; listen 80; listen [::]:80; server_name rainmar.com www.rainmar.com; index index.html; location / &#123; alias /data/projects/blog/; index index.html; try_files $uri $uri/ /index.html =404; &#125;&#125; ③ 重启nginx1/etc/init.d/nginx restart 5.hexo deploy① 安装deploy1$ npm install hexo-deployer-git --save ② 打开博客项目根目录下_config.yml文件,配置如下1234deploy: type: git repository: git@ip或域名:/path/to/blog.git branch: master ③配置一键部署，打开package.json文件1234567\"scripts\": &#123; \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\", \"c\": \"npm run clean &amp; npm run build &amp; npm run deploy\" &#125; npm run c 服务器一键部署（一键执行清理，构建，部署服务器） 参考文献、文档git仓库和项目源码分离 git init 和 git init –bare HEXO 部署到云服务器详细指南","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://rainmar.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"服务器","slug":"服务器","permalink":"http://rainmar.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}]}